package parser

import (
	"fmt"
	"strconv"
	"strings"
)

func (p *Parser) PrintState() {
	loc := getLineInfo(p.input, p.pos)
	t := tokenToString[p.Type.identifier]
	line := strconv.Itoa(loc.Line)
	column := strconv.Itoa(loc.Column)
	message := strings.Join([]string{" (", line, ":", column, ")"}, "")

	fmt.Printf("Parser state: \n line:column"+message+"\n position: %d \n current type: %s\n\n", p.pos, t)
}

// Maps for json marshalling
var nodeTypeToString = map[NodeType]string{
	NODE_IDENTIFIER:                     "Identifier",
	NODE_LITERAL:                        "Literal",
	NODE_PROGRAM:                        "Program",
	NODE_FUNCTION:                       "Function",
	NODE_EXPRESSION_STATEMENT:           "ExpressionStatement",
	NODE_BLOCK_STATEMENT:                "BlockStatement",
	NODE_EMPTY_STATEMENT:                "EmptyStatement",
	NODE_DEBUGGER_STATEMENT:             "DebuggerStatement",
	NODE_WITH_STATEMENT:                 "WithStatement",
	NODE_RETURN_STATEMENT:               "ReturnStatement",
	NODE_LABELED_STATEMENT:              "LabeledStatement",
	NODE_BREAK_STATEMENT:                "BreakStatement",
	NODE_CONTINUE_STATEMENT:             "ContinueStatement",
	NODE_IF_STATEMENT:                   "IfStatement",
	NODE_SWITCH_STATEMENT:               "SwitchStatement",
	NODE_SWITCH_CASE:                    "SwitchCase",
	NODE_THROW_STATEMENT:                "ThrowStatement",
	NODE_TRY_STATEMENT:                  "TryStatement",
	NODE_CATCH_CLAUSE:                   "CatchClause",
	NODE_WHILE_STATEMENT:                "WhileStatement",
	NODE_DO_WHILE_STATEMENT:             "DoWhileStatement",
	NODE_FOR_STATEMENT:                  "ForStatement",
	NODE_FOR_IN_STATEMENT:               "ForInStatement",
	NODE_FUNCTION_DECLARATION:           "FunctionDeclaration",
	NODE_VARIABLE_DECLARATION:           "VariableDeclaration",
	NODE_VARIABLE_DECLARATOR:            "VariableDeclarator",
	NODE_THIS_EXPRESSION:                "ThisExpression",
	NODE_ARRAY_EXPRESSION:               "ArrayExpression",
	NODE_OBJECT_EXPRESSION:              "ObjectExpression",
	NODE_PROPERTY:                       "Property",
	NODE_FUNCTION_EXPRESSION:            "FunctionExpression",
	NODE_UNARY_EXPRESSION:               "UnaryExpression",
	NODE_UPDATE_EXPRESSION:              "UpdateExpression",
	NODE_BINARY_EXPRESSION:              "BinaryExpression",
	NODE_ASSIGNMENT_EXPRESSION:          "AssignmentExpression",
	NODE_LOGICAL_EXPRESSION:             "LogicalExpression",
	NODE_MEMBER_EXPRESSION:              "MemberExpression",
	NODE_CONDITIONAL_EXPRESSION:         "ConditionalExpression",
	NODE_CALL_EXPRESSION:                "CallExpression",
	NODE_NEW_EXPRESSION:                 "NewExpression",
	NODE_SEQUENCE_EXPRESSION:            "SequenceExpression",
	NODE_FOR_OF_STATEMENT:               "ForOfStatement",
	NODE_SUPER:                          "Super",
	NODE_SPREAD_ELEMENT:                 "SpreadElement",
	NODE_ARROW_FUNCTION_EXPRESSION:      "ArrowFunctionExpression",
	NODE_YIELD_EXPRESSION:               "YieldExpression",
	NODE_TEMPLATE_LITERAL:               "TemplateLiteral",
	NODE_TAGGED_TEMPLATE_EXPRESSION:     "TaggedTemplateExpression",
	NODE_TEMPLATE_ELEMENT:               "TemplateElement",
	NODE_ASSIGNMENT_PROPERTY:            "AssignmentProperty",
	NODE_OBJECT_PATTERN:                 "ObjectPattern",
	NODE_ARRAY_PATTERN:                  "ArrayPattern",
	NODE_REST_ELEMENT:                   "RestElement",
	NODE_ASSIGNMENT_PATTERN:             "AssignmentPattern",
	NODE_CLASS:                          "Class",
	NODE_CLASS_BODY:                     "ClassBody",
	NODE_METHOD_DEFINITION:              "MethodDefinition",
	NODE_CLASS_DECLARATION:              "ClassDeclaration",
	NODE_CLASS_EXPRESSION:               "ClassExpression",
	NODE_META_PROPERTY:                  "MetaProperty",
	NODE_IMPORT_DECLARATION:             "ImportDeclaration",
	NODE_IMPORT_SPECIFIER:               "ImportSpecifier",
	NODE_IMPORT_DEFAULT_SPECIFIER:       "ImportDefaultSpecifier",
	NODE_IMPORT_NAMESPACE_SPECIFIER:     "ImportNamespaceSpecifier",
	NODE_IMPORT_ATTRIBUTE:               "ImportAttribute",
	NODE_EXPORT_NAMED_DECLARATION:       "ExportNamedDeclaration",
	NODE_EXPORT_SPECIFIER:               "ExportSpecifier",
	NODE_ANONYMOUS_FUNCTION_DECLARATION: "AnonymousFunctionDeclaration",
	NODE_ANONYMOUS_CLASS_DECLARATION:    "AnonymousClassDeclaration",
	NODE_EXPORT_DEFAULT_DECLARATION:     "ExportDefaultDeclaration",
	NODE_EXPORT_ALL_DECLARATION:         "ExportAllDeclaration",
	NODE_AWAIT_EXPRESSION:               "AwaitExpression",
	NODE_CHAIN_EXPRESSION:               "ChainExpression",
	NODE_IMPORT_EXPRESSION:              "ImportExpression",
	NODE_PARENTHESIZED_EXPRESSION:       "ParenthesizedExpression",
	NODE_PROPERTY_DEFINITION:            "PropertyDefinition",
	NODE_PRIVATE_IDENTIFIER:             "PrivateIdentifier",
	NODE_STATIC_BLOCK:                   "StaticBlock",
	NODE_UNTYPED:                        "Untyped",
}
var stringToNodeType = map[string]NodeType{
	"Identifier":                   NODE_IDENTIFIER,
	"Literal":                      NODE_LITERAL,
	"Program":                      NODE_PROGRAM,
	"Function":                     NODE_FUNCTION,
	"ExpressionStatement":          NODE_EXPRESSION_STATEMENT,
	"BlockStatement":               NODE_BLOCK_STATEMENT,
	"EmptyStatement":               NODE_EMPTY_STATEMENT,
	"DebuggerStatement":            NODE_DEBUGGER_STATEMENT,
	"WithStatement":                NODE_WITH_STATEMENT,
	"ReturnStatement":              NODE_RETURN_STATEMENT,
	"LabeledStatement":             NODE_LABELED_STATEMENT,
	"BreakStatement":               NODE_BREAK_STATEMENT,
	"ContinueStatement":            NODE_CONTINUE_STATEMENT,
	"IfStatement":                  NODE_IF_STATEMENT,
	"SwitchStatement":              NODE_SWITCH_STATEMENT,
	"SwitchCase":                   NODE_SWITCH_CASE,
	"ThrowStatement":               NODE_THROW_STATEMENT,
	"TryStatement":                 NODE_TRY_STATEMENT,
	"CatchClause":                  NODE_CATCH_CLAUSE,
	"WhileStatement":               NODE_WHILE_STATEMENT,
	"DoWhileStatement":             NODE_DO_WHILE_STATEMENT,
	"ForStatement":                 NODE_FOR_STATEMENT,
	"ForInStatement":               NODE_FOR_IN_STATEMENT,
	"FunctionDeclaration":          NODE_FUNCTION_DECLARATION,
	"VariableDeclaration":          NODE_VARIABLE_DECLARATION,
	"VariableDeclarator":           NODE_VARIABLE_DECLARATOR,
	"ThisExpression":               NODE_THIS_EXPRESSION,
	"ArrayExpression":              NODE_ARRAY_EXPRESSION,
	"ObjectExpression":             NODE_OBJECT_EXPRESSION,
	"Property":                     NODE_PROPERTY,
	"FunctionExpression":           NODE_FUNCTION_EXPRESSION,
	"UnaryExpression":              NODE_UNARY_EXPRESSION,
	"UpdateExpression":             NODE_UPDATE_EXPRESSION,
	"BinaryExpression":             NODE_BINARY_EXPRESSION,
	"AssignmentExpression":         NODE_ASSIGNMENT_EXPRESSION,
	"LogicalExpression":            NODE_LOGICAL_EXPRESSION,
	"MemberExpression":             NODE_MEMBER_EXPRESSION,
	"ConditionalExpression":        NODE_CONDITIONAL_EXPRESSION,
	"CallExpression":               NODE_CALL_EXPRESSION,
	"NewExpression":                NODE_NEW_EXPRESSION,
	"SequenceExpression":           NODE_SEQUENCE_EXPRESSION,
	"ForOfStatement":               NODE_FOR_OF_STATEMENT,
	"Super":                        NODE_SUPER,
	"SpreadElement":                NODE_SPREAD_ELEMENT,
	"ArrowFunctionExpression":      NODE_ARROW_FUNCTION_EXPRESSION,
	"YieldExpression":              NODE_YIELD_EXPRESSION,
	"TemplateLiteral":              NODE_TEMPLATE_LITERAL,
	"TaggedTemplateExpression":     NODE_TAGGED_TEMPLATE_EXPRESSION,
	"TemplateElement":              NODE_TEMPLATE_ELEMENT,
	"AssignmentProperty":           NODE_ASSIGNMENT_PROPERTY,
	"ObjectPattern":                NODE_OBJECT_PATTERN,
	"ArrayPattern":                 NODE_ARRAY_PATTERN,
	"RestElement":                  NODE_REST_ELEMENT,
	"AssignmentPattern":            NODE_ASSIGNMENT_PATTERN,
	"Class":                        NODE_CLASS,
	"ClassBody":                    NODE_CLASS_BODY,
	"MethodDefinition":             NODE_METHOD_DEFINITION,
	"ClassDeclaration":             NODE_CLASS_DECLARATION,
	"ClassExpression":              NODE_CLASS_EXPRESSION,
	"MetaProperty":                 NODE_META_PROPERTY,
	"ImportDeclaration":            NODE_IMPORT_DECLARATION,
	"ImportSpecifier":              NODE_IMPORT_SPECIFIER,
	"ImportDefaultSpecifier":       NODE_IMPORT_DEFAULT_SPECIFIER,
	"ImportNamespaceSpecifier":     NODE_IMPORT_NAMESPACE_SPECIFIER,
	"ImportAttribute":              NODE_IMPORT_ATTRIBUTE,
	"ExportNamedDeclaration":       NODE_EXPORT_NAMED_DECLARATION,
	"ExportSpecifier":              NODE_EXPORT_SPECIFIER,
	"AnonymousFunctionDeclaration": NODE_ANONYMOUS_FUNCTION_DECLARATION,
	"AnonymousClassDeclaration":    NODE_ANONYMOUS_CLASS_DECLARATION,
	"ExportDefaultDeclaration":     NODE_EXPORT_DEFAULT_DECLARATION,
	"ExportAllDeclaration":         NODE_EXPORT_ALL_DECLARATION,
	"AwaitExpression":              NODE_AWAIT_EXPRESSION,
	"ChainExpression":              NODE_CHAIN_EXPRESSION,
	"ImportExpression":             NODE_IMPORT_EXPRESSION,
	"ParenthesizedExpression":      NODE_PARENTHESIZED_EXPRESSION,
	"PropertyDefinition":           NODE_PROPERTY_DEFINITION,
	"PrivateIdentifier":            NODE_PRIVATE_IDENTIFIER,
	"StaticBlock":                  NODE_STATIC_BLOCK,
	"Untyped":                      NODE_UNTYPED,
}
var kindToString = map[Kind]string{
	KIND_NOT_INITIALIZED:   "notInitialized",
	KIND_DECLARATION_VAR:   "var",
	KIND_DECLARATION_LET:   "let",
	KIND_DECLARATION_CONST: "const",
	KIND_PROPERTY_GET:      "get",
	KIND_PROPERTY_SET:      "set",
	KIND_PROPERTY_INIT:     "init",
	KIND_PROPERTY_METHOD:   "method",
	KIND_CONSTRUCTOR:       "constructor",
}

var stringToKind = map[string]Kind{
	"notInitialized": KIND_NOT_INITIALIZED,
	"var":            KIND_DECLARATION_VAR,
	"let":            KIND_DECLARATION_LET,
	"const":          KIND_DECLARATION_CONST,
	"get":            KIND_PROPERTY_GET,
	"set":            KIND_PROPERTY_SET,
	"init":           KIND_PROPERTY_INIT,
	"method":         KIND_PROPERTY_METHOD,
	"constructor":    KIND_CONSTRUCTOR,
}

var tokenToString = map[Token]string{
	// BASIC
	TOKEN_NUM:       "Num",
	TOKEN_REGEXP:    "RegExp",
	TOKEN_STRING:    "String",
	TOKEN_NAME:      "Name",
	TOKEN_PRIVATEID: "PrivateId",
	TOKEN_EOF:       "EOF",

	// PUNCTUATION
	TOKEN_BRACKETL:        "BracketL",
	TOKEN_BRACKETR:        "BracketR",
	TOKEN_BRACEL:          "BraceL",
	TOKEN_BRACER:          "BraceR",
	TOKEN_PARENL:          "ParenL",
	TOKEN_PARENR:          "ParenR",
	TOKEN_COMMA:           "Comma",
	TOKEN_SEMI:            "Semi",
	TOKEN_COLON:           "Colon",
	TOKEN_DOT:             "Dot",
	TOKEN_QUESTION:        "Question",
	TOKEN_QUESTIONDOT:     "QuestionDot",
	TOKEN_ARROW:           "Arrow",
	TOKEN_TEMPLATE:        "Template",
	TOKEN_INVALIDTEMPLATE: "InvalidTemplate",
	TOKEN_ELLIPSIS:        "Ellipsis",
	TOKEN_BACKQUOTE:       "BackQuote",
	TOKEN_DOLLARBRACEL:    "DollarBraceL",

	// Operator token types
	TOKEN_EQ:         "Eq",
	TOKEN_ASSIGN:     "Assign",
	TOKEN_INCDEC:     "IncDec",
	TOKEN_PREFIX:     "Prefix",
	TOKEN_LOGICALOR:  "LogicalOr",
	TOKEN_LOGICALAND: "LogicalAnd",
	TOKEN_BITWISEOR:  "BitwiseOr",
	TOKEN_BITWISEXOR: "BitwiseXor",
	TOKEN_BITWISEAND: "BitwiseAnd",
	TOKEN_EQUALITY:   "Equality",
	TOKEN_RELATIONAL: "Relational",
	TOKEN_BITSHIFT:   "BitShift",
	TOKEN_PLUSMIN:    "PlusMin",
	TOKEN_MODULO:     "Modulo",
	TOKEN_STAR:       "Star",
	TOKEN_SLASH:      "Slash",
	TOKEN_STARSTAR:   "StarStar",
	TOKEN_COALESCE:   "Coalesce",

	// Keywords
	TOKEN_BREAK:      "Break",
	TOKEN_CASE:       "Case",
	TOKEN_CATCH:      "Catch",
	TOKEN_CONTINUE:   "Continue",
	TOKEN_DEBUGGER:   "Debugger",
	TOKEN_DEFAULT:    "Default",
	TOKEN_DO:         "Do",
	TOKEN_ELSE:       "Else",
	TOKEN_FINALLY:    "Finally",
	TOKEN_FOR:        "For",
	TOKEN_FUNCTION:   "Function",
	TOKEN_IF:         "If",
	TOKEN_RETURN:     "Return",
	TOKEN_SWITCH:     "Switch",
	TOKEN_THROW:      "Throw",
	TOKEN_TRY:        "Try",
	TOKEN_VAR:        "Var",
	TOKEN_CONST:      "Const",
	TOKEN_WHILE:      "While",
	TOKEN_WITH:       "With",
	TOKEN_NEW:        "New",
	TOKEN_THIS:       "This",
	TOKEN_SUPER:      "Super",
	TOKEN_CLASS:      "Class",
	TOKEN_EXTENDS:    "Extends",
	TOKEN_EXPORT:     "Export",
	TOKEN_IMPORT:     "Import",
	TOKEN_NULL:       "Null",
	TOKEN_TRUE:       "True",
	TOKEN_FALSE:      "False",
	TOKEN_IN:         "In",
	TOKEN_INSTANCEOF: "Instanceof",
	TOKEN_TYPEOF:     "Typeof",
	TOKEN_VOID:       "Void",
	TOKEN_DELETE:     "Delete",
}
